# Beyond Basic CRUD

By default graphqlizer provides basic CRUD mutations / queries. You can disable
operations by providing the `crud` configuration.

```js
import { createCollectionSchema } from 'meteor/easy:graphqlizer'
import { UserTypeSchema, UserInputSchema } from '{...}'

const userSchema = createCollectionSchema({ 
  type: 'User',
  collection: UserCollection,
  schema: {
    type: UserTypeSchema,
    input: UserInputSchema,
  },
  crud: {
    delete: false,
    update: false,
  },
})
```

Use `delete`, `update`, `create` or `read` as keys and just set what you don't
want to be exposed over GraphQL to be `false`. 

## Adding or changing mutations and queries

You can use basic GraphQL `typeDefs` and `resolvers`
to add change mutations and queries.

Let's say you have the above userSchema without the delete and update functionality and 
you create a new `userCustomizedSchema` that looks like following.

```js
const userCustomizedSchema = {
  resolvers: {
    Query: {
      listRandomUser(_, args, context) {
        return UserCollection.find({ ... }).fetch()
      },
    },
    Mutation: {
      deleteUser(_, args, context) {
        if (args.id === context.userId) {
          // ...
        }
        
        // throw some custom event
      },
    },
  },
  typeDefs: [`
extend type Query {
  listRandomUser: User
}

extend type Mutation {
  deleteUser(_id: String!): User
}
  `]
}

// pass this schema to generateTypeDefsAndResolvers call
```

This is the basic GraphQL schema definition + resolvers to introduce a `listRandomUser` query 
and a `deleteUser` method with custom business logic. 

The schemas generated by
`createCollectionSchema` have the same structure as the customized schema we created above.
Having a look at the generated resolvers and type defs also makes it possible to easily replace
graphqlizer with a custom schema if your business needs outgrows the generated schema.
